#ifndef _KODO_ENCODE_
#define _KODO_ENCODE_

#include <cassert>
#include <csignal>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>

#include <kodocpp/kodocpp.hpp>
#include <iostream>

const char* encode(uint8_t* data, int size)
{
    uint32_t symbol_size = 1024;
    uint32_t symbols = size / symbol_size ;

    if(symbols == 0) symbols = 1;

    // Initialize the factory with the chosen symbols and symbol size
    kodocpp::encoder_factory encoder_factory(
        kodocpp::codec::on_the_fly,
        kodocpp::field::binary8,
        symbols, symbol_size);

    kodocpp::encoder encoder = encoder_factory.build();

    // Create the buffer needed for the payload
    uint32_t payload_size = encoder.payload_size();
    std::vector<uint8_t> payload(payload_size);
    std::vector<uint8_t> data_in(data, data+size); 
    std::vector<uint8_t> data_out;
    // std::cout<<data_out.data()<<std::endl;


    for (uint32_t i = 0; i < symbols; ++i)
    {
        // Add a new symbol if the encoder rank is less than the maximum number
        // of symbols
        uint32_t rank = encoder.rank();
        if (rank < encoder.symbols())
        {
            // Calculate the offset to the next symbol to insert
            uint8_t* symbol = data_in.data() + rank * encoder.symbol_size();
            encoder.set_const_symbol(rank, symbol, encoder.symbol_size());
        }
        uint32_t bytes_used = encoder.write_payload(payload.data());
        // printf("Payload generated by encoder, rank = %d, bytes used = %d\n",
        //        encoder.rank(), bytes_used);
        std::cout<<payload.size()<<' '<<payload.data()<<'\n';
        
        data_out.insert(data_out.end(), payload.begin(), payload.end());
        
        // return_code = sendto(socket_descriptor, (const char*)payload.data(),
        //                      bytes_used, 0, (struct sockaddr*) &remote_address,
        //                      sizeof(remote_address));

        // if (return_code < 0)
        // {
        //     printf("%s: cannot send packet %d \n", argv[0], i - 1);
        //     exit(1);
        // }

        // sleep_here(delay);
    }
    return (const char*)data_out.data();
}

#endif
